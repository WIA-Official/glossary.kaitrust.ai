<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymorphism (다형성) | KAITRUST AI 백과사전</title>
    <meta name="description" content="같은 인터페이스로 다른 동작을 수행하는 OOP 핵심 원칙. 서브타입, 파라메트릭, Ad-hoc 다형성을 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다.">
    <meta name="keywords" content="Polymorphism, 다형성, OOP, 객체지향, 오버라이딩, 오버로딩, 전략 패턴, AI 용어, KAITRUST, AI 백과사전, 프로그래밍">
    <link rel="canonical" href="https://glossary.kaitrust.ai/ko/term/Polymorphism/">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://glossary.kaitrust.ai/ko/term/Polymorphism/">
    <meta property="og:title" content="Polymorphism (다형성) | KAITRUST AI 백과사전">
    <meta property="og:description" content="같은 인터페이스로 다른 동작을 수행하는 OOP 핵심 원칙. 서브타입, 파라메트릭, Ad-hoc 다형성을 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다.">
    <meta property="og:image" content="https://kaitrust.ai/images/og-glossary.png">
    <meta property="og:locale" content="ko_KR">
    <meta property="og:site_name" content="KAITRUST AI 백과사전">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Polymorphism (다형성) | KAITRUST AI 백과사전">
    <meta name="twitter:description" content="같은 인터페이스로 다른 동작을 수행하는 OOP 핵심 원칙. 서브타입, 파라메트릭, Ad-hoc 다형성을 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다.">
    <meta name="twitter:image" content="https://kaitrust.ai/images/og-glossary.png">

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "DefinedTerm",
        "name": "Polymorphism",
        "description": "같은 인터페이스로 다른 동작을 수행하는 OOP 핵심 원칙. 서브타입, 파라메트릭, Ad-hoc 다형성을 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다.",
        "inDefinedTermSet": {
            "@type": "DefinedTermSet",
            "name": "KAITRUST AI 백과사전",
            "url": "https://glossary.kaitrust.ai/"
        }
    }
    </script>

    <link rel="icon" type="image/png" href="https://kaitrust.ai/favicon.png">
    <link rel="apple-touch-icon" href="https://kaitrust.ai/favicon.png">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&family=Noto+Sans+KR:wght@300;400;500;700;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- Common CSS -->
    <link rel="stylesheet" href="/css/kaitrust-common.css">
    <link rel="stylesheet" href="/css/light-mode.css">
    <link rel="stylesheet" href="/components/ask-ai/kaitrust-ai-modal.css">

    <style>
        .term-detail-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 120px 2rem 4rem;
            position: relative;
            z-index: 1;
        }
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
            font-size: 0.9rem;
            flex-wrap: wrap;
        }
        .breadcrumb a {
            color: #64748b;
            text-decoration: none;
            transition: color 0.2s;
        }
        .breadcrumb a:hover { color: var(--primary); }
        .breadcrumb span { color: #64748b; }
        .breadcrumb .current { color: var(--accent); font-weight: 500; }
        .term-detail-header {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.6));
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 24px;
            padding: 3rem;
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }
        .term-category-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(168, 85, 247, 0.2);
            border-radius: 20px;
            font-size: 0.85rem;
            color: #a855f7;
            margin-bottom: 1rem;
        }
        .term-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #ffffff, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .term-english {
            font-size: 1.2rem;
            color: #94a3b8;
            margin-bottom: 1.5rem;
        }
        .term-description {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #e2e8f0;
        }
        .term-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
        }
        .term-action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-size: 0.9rem;
            text-decoration: none;
            transition: all 0.3s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #a855f7, #6366f1);
            color: white;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(168, 85, 247, 0.3);
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Content Sections */
        .term-section {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.6), rgba(30, 41, 59, 0.4));
            border: 1px solid rgba(168, 85, 247, 0.15);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }
        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .section-title .icon {
            font-size: 1.4rem;
        }
        .detail-content {
            color: #cbd5e1;
            line-height: 1.9;
            font-size: 1rem;
        }
        .detail-content p {
            margin-bottom: 1rem;
        }
        .detail-content p:last-child {
            margin-bottom: 0;
        }
        .detail-content strong {
            color: #e2e8f0;
            font-weight: 600;
        }

        /* Code Block */
        .code-block {
            background: #0d1117;
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 12px;
            overflow: hidden;
            margin: 1rem 0;
        }
        .code-header {
            background: rgba(168, 85, 247, 0.1);
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }
        .code-lang {
            color: #a855f7;
            font-size: 0.85rem;
            font-weight: 500;
        }
        .copy-btn {
            background: rgba(168, 85, 247, 0.2);
            border: none;
            color: #e2e8f0;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        .copy-btn:hover {
            background: rgba(168, 85, 247, 0.4);
        }
        .copy-btn.copied {
            background: rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }
        .code-content {
            padding: 1.25rem;
            overflow-x: auto;
        }
        .code-content pre {
            margin: 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #e6edf3;
        }
        .code-content .comment { color: #8b949e; }
        .code-content .keyword { color: #ff7b72; }
        .code-content .string { color: #a5d6ff; }
        .code-content .function { color: #d2a8ff; }
        .code-content .type { color: #79c0ff; }
        .code-content .decorator { color: #ffa657; }
        .code-content .number { color: #79c0ff; }

        /* Conversation */
        .conversation-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .conversation-item {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(100, 116, 139, 0.2);
        }
        .conversation-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        .avatar-reviewer {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
        }
        .avatar-developer {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        .avatar-interviewer {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        .avatar-candidate {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }
        .conversation-content {
            flex: 1;
        }
        .conversation-role {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
        }
        .role-reviewer { color: #a5b4fc; }
        .role-developer { color: #6ee7b7; }
        .role-interviewer { color: #fcd34d; }
        .role-candidate { color: #93c5fd; }
        .conversation-text {
            color: #cbd5e1;
            font-size: 0.95rem;
            line-height: 1.6;
        }
        .conversation-text code {
            background: rgba(168, 85, 247, 0.2);
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: #e2e8f0;
        }
        .conversation-divider {
            border: none;
            border-top: 1px dashed rgba(100, 116, 139, 0.3);
            margin: 0.5rem 0;
        }
        .conversation-label {
            font-size: 0.85rem;
            color: #64748b;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
        }

        /* Warning Box */
        .warning-box {
            background: linear-gradient(145deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.05));
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 12px;
            padding: 1.25rem;
            margin: 1rem 0;
        }
        .warning-title {
            color: #fbbf24;
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .warning-list {
            color: #fcd34d;
            font-size: 0.9rem;
            line-height: 1.7;
            padding-left: 1.25rem;
            margin: 0;
        }
        .warning-list li {
            margin-bottom: 0.5rem;
        }
        .warning-list li:last-child {
            margin-bottom: 0;
        }

        /* Related Terms */
        .related-terms {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .related-term-link {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 1rem;
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.2);
            border-radius: 20px;
            color: #c4b5fd;
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .related-term-link:hover {
            background: rgba(168, 85, 247, 0.2);
            border-color: rgba(168, 85, 247, 0.4);
            transform: translateY(-2px);
        }

        /* Learn More */
        .learn-more-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .learn-more-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(100, 116, 139, 0.2);
            border-radius: 10px;
            text-decoration: none;
            color: #e2e8f0;
            transition: all 0.2s;
        }
        .learn-more-item:hover {
            background: rgba(168, 85, 247, 0.1);
            border-color: rgba(168, 85, 247, 0.3);
            transform: translateX(5px);
        }
        .learn-more-icon {
            font-size: 1.5rem;
        }
        .learn-more-content {
            flex: 1;
        }
        .learn-more-title {
            font-weight: 500;
            margin-bottom: 0.2rem;
        }
        .learn-more-desc {
            font-size: 0.85rem;
            color: #94a3b8;
        }

        @media (max-width: 768px) {
            .term-detail-container { padding: 100px 1rem 2rem; }
            .term-detail-header { padding: 2rem 1.5rem; }
            .term-title { font-size: 1.8rem; }
            .term-section { padding: 1.5rem; }
            .conversation-item { flex-direction: column; gap: 0.75rem; }
            .code-content pre { font-size: 0.8rem; }
        }
    </style>
    <link rel="stylesheet" href="/glossary/css/term-sections.css">

</head>
<body>
    <!-- Particle Background -->
    <div class="particle-container" id="particles"></div>

    <!-- Header -->
        <div id="kaitrust-header"></div>

    <main class="term-detail-container">
        <!-- Breadcrumb -->
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="https://kaitrust.ai">홈</a>
            <span>&#8250;</span>
            <a href="https://glossary.kaitrust.ai">AI 백과사전</a>
            <span>&#8250;</span>
            <a href="https://glossary.kaitrust.ai/#prog">프로그래밍</a>
            <span>&#8250;</span>
            <span class="current">Polymorphism</span>
        </nav>

        <!-- Term Header -->
        <article class="term-detail-header">
            <div class="term-category-badge">
                <span>&#128187;</span>
                <span>프로그래밍</span>
            </div>
            <h1 class="term-title">Polymorphism</h1>
            <p class="term-english">다형성</p>
            <div class="term-description">
                <p>같은 인터페이스로 다른 동작을 수행하는 OOP 핵심 원칙. 코드의 유연성과 확장성을 높이며, 전략 패턴과 의존성 주입의 기반이 됩니다.</p>
            </div>
            <div class="term-actions">
                <a href="https://glossary.kaitrust.ai" class="term-action-btn btn-primary">
                    &#128218; 전체 용어 보기
                </a>
                <a href="https://glossary.kaitrust.ai/#prog" class="term-action-btn btn-secondary">
                    &#128187; 프로그래밍 더보기
                </a>
            </div>
        </article>

        <!-- Detailed Description -->
        <section class="term-section">
            <h2 class="section-title">
                <span class="icon">&#128214;</span>
                상세 설명
            </h2>
            <div class="detail-content">
                <p>
                    <strong>다형성(Polymorphism)</strong>은 그리스어로 "많은 형태"를 의미하며, 객체지향 프로그래밍(OOP)의 4대 핵심 원칙 중 하나입니다. 같은 인터페이스나 메서드 시그니처를 통해 서로 다른 타입의 객체들이 각자의 방식으로 동작할 수 있게 해줍니다. 예를 들어, <code>draw()</code> 메서드를 호출하면 Circle은 원을, Rectangle은 사각형을 그리는 것처럼, 호출하는 코드는 동일하지만 실제 동작은 객체의 타입에 따라 달라집니다.
                </p>
                <p>
                    다형성은 크게 세 가지 종류로 분류됩니다. <strong>서브타입 다형성(Subtype Polymorphism)</strong>은 상속을 통해 부모 클래스 타입으로 자식 클래스 객체를 다루는 것으로, 가장 일반적인 형태입니다. <strong>파라메트릭 다형성(Parametric Polymorphism)</strong>은 제네릭(Generic)을 통해 타입을 매개변수화하는 것으로, <code>List&lt;T&gt;</code>처럼 어떤 타입이든 담을 수 있는 컬렉션이 대표적입니다. <strong>Ad-hoc 다형성</strong>은 메서드 오버로딩을 통해 같은 이름의 메서드가 다른 매개변수를 받는 것입니다.
                </p>
                <p>
                    <strong>오버라이딩(Overriding)</strong>과 <strong>오버로딩(Overloading)</strong>은 다형성의 대표적인 구현 방식입니다. 오버라이딩은 자식 클래스가 부모 클래스의 메서드를 재정의하는 것으로, 런타임에 어떤 메서드가 호출될지 결정됩니다(동적 바인딩). 반면 오버로딩은 같은 클래스 내에서 같은 이름의 메서드를 매개변수만 다르게 정의하는 것으로, 컴파일 타임에 호출할 메서드가 결정됩니다(정적 바인딩). Python은 오버로딩을 직접 지원하지 않고 기본값 매개변수나 <code>*args</code>로 유사한 효과를 냅니다.
                </p>
                <p>
                    실무에서 다형성은 <strong>전략 패턴(Strategy Pattern)</strong>과 <strong>의존성 주입(Dependency Injection)</strong>의 핵심입니다. 전략 패턴은 알고리즘을 인터페이스로 정의하고 런타임에 구현체를 교체할 수 있게 해줍니다. 의존성 주입은 구체 클래스가 아닌 인터페이스에 의존하게 하여, 테스트 시 Mock 객체로 쉽게 교체할 수 있습니다. Spring Framework, React의 Context API, Python의 추상 클래스 등 현대 프레임워크들은 다형성을 적극 활용하여 확장 가능하고 테스트하기 쉬운 구조를 만듭니다.
                </p>
            </div>
        </section>

        <!-- Code Example -->
        <section class="term-section">
            <h2 class="section-title">
                <span class="icon">&#128187;</span>
                코드 예제
            </h2>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-lang">Java - 서브타입 다형성과 전략 패턴</span>
                    <button class="copy-btn" onclick="copyCode(this)">복사</button>
                </div>
                <div class="code-content">
                    <pre><span class="comment">// 1. 인터페이스 정의 (다형성의 기반)</span>
<span class="keyword">interface</span> <span class="type">PaymentStrategy</span> {
    <span class="keyword">void</span> <span class="function">pay</span>(<span class="keyword">int</span> amount);
}

<span class="comment">// 2. 다양한 구현체 (같은 인터페이스, 다른 동작)</span>
<span class="keyword">class</span> <span class="type">CreditCardPayment</span> <span class="keyword">implements</span> <span class="type">PaymentStrategy</span> {
    <span class="keyword">private</span> <span class="type">String</span> cardNumber;

    <span class="keyword">public</span> <span class="function">CreditCardPayment</span>(<span class="type">String</span> cardNumber) {
        <span class="keyword">this</span>.cardNumber = cardNumber;
    }

    <span class="decorator">@Override</span>
    <span class="keyword">public void</span> <span class="function">pay</span>(<span class="keyword">int</span> amount) {
        System.out.<span class="function">println</span>(<span class="string">"카드 "</span> + cardNumber + <span class="string">"로 "</span> + amount + <span class="string">"원 결제"</span>);
    }
}

<span class="keyword">class</span> <span class="type">KakaoPayPayment</span> <span class="keyword">implements</span> <span class="type">PaymentStrategy</span> {
    <span class="decorator">@Override</span>
    <span class="keyword">public void</span> <span class="function">pay</span>(<span class="keyword">int</span> amount) {
        System.out.<span class="function">println</span>(<span class="string">"카카오페이로 "</span> + amount + <span class="string">"원 결제"</span>);
    }
}

<span class="comment">// 3. 다형성 활용 (구체 클래스가 아닌 인터페이스에 의존)</span>
<span class="keyword">class</span> <span class="type">ShoppingCart</span> {
    <span class="keyword">private</span> <span class="type">PaymentStrategy</span> paymentStrategy;  <span class="comment">// 인터페이스 타입</span>

    <span class="comment">// 의존성 주입 (런타임에 구현체 교체 가능)</span>
    <span class="keyword">public void</span> <span class="function">setPaymentStrategy</span>(<span class="type">PaymentStrategy</span> strategy) {
        <span class="keyword">this</span>.paymentStrategy = strategy;
    }

    <span class="keyword">public void</span> <span class="function">checkout</span>(<span class="keyword">int</span> amount) {
        paymentStrategy.<span class="function">pay</span>(amount);  <span class="comment">// 어떤 구현체든 동일하게 호출</span>
    }
}

<span class="comment">// 사용 예시</span>
ShoppingCart cart = <span class="keyword">new</span> <span class="function">ShoppingCart</span>();
cart.<span class="function">setPaymentStrategy</span>(<span class="keyword">new</span> <span class="function">CreditCardPayment</span>(<span class="string">"1234-5678"</span>));
cart.<span class="function">checkout</span>(<span class="number">50000</span>);  <span class="comment">// 카드 결제</span>

cart.<span class="function">setPaymentStrategy</span>(<span class="keyword">new</span> <span class="function">KakaoPayPayment</span>());
cart.<span class="function">checkout</span>(<span class="number">30000</span>);  <span class="comment">// 카카오페이 결제</span></pre>
                </div>
            </div>
            <div class="code-block">
                <div class="code-header">
                    <span class="code-lang">Python - Duck Typing과 추상 클래스</span>
                    <button class="copy-btn" onclick="copyCode(this)">복사</button>
                </div>
                <div class="code-content">
                    <pre><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod

<span class="comment"># 1. 추상 클래스 정의</span>
<span class="keyword">class</span> <span class="type">Shape</span>(ABC):
    <span class="decorator">@abstractmethod</span>
    <span class="keyword">def</span> <span class="function">area</span>(self) -> <span class="type">float</span>:
        <span class="keyword">pass</span>

    <span class="decorator">@abstractmethod</span>
    <span class="keyword">def</span> <span class="function">draw</span>(self) -> <span class="type">str</span>:
        <span class="keyword">pass</span>

<span class="comment"># 2. 구체 클래스들 (같은 메서드, 다른 동작)</span>
<span class="keyword">class</span> <span class="type">Circle</span>(Shape):
    <span class="keyword">def</span> <span class="function">__init__</span>(self, radius: <span class="type">float</span>):
        self.radius = radius

    <span class="keyword">def</span> <span class="function">area</span>(self) -> <span class="type">float</span>:
        <span class="keyword">return</span> <span class="number">3.14159</span> * self.radius ** <span class="number">2</span>

    <span class="keyword">def</span> <span class="function">draw</span>(self) -> <span class="type">str</span>:
        <span class="keyword">return</span> <span class="string">f"반지름 {self.radius}인 원을 그립니다"</span>

<span class="keyword">class</span> <span class="type">Rectangle</span>(Shape):
    <span class="keyword">def</span> <span class="function">__init__</span>(self, width: <span class="type">float</span>, height: <span class="type">float</span>):
        self.width = width
        self.height = height

    <span class="keyword">def</span> <span class="function">area</span>(self) -> <span class="type">float</span>:
        <span class="keyword">return</span> self.width * self.height

    <span class="keyword">def</span> <span class="function">draw</span>(self) -> <span class="type">str</span>:
        <span class="keyword">return</span> <span class="string">f"{self.width}x{self.height} 사각형을 그립니다"</span>

<span class="comment"># 3. 다형성 활용 (타입에 관계없이 동일한 방식으로 처리)</span>
<span class="keyword">def</span> <span class="function">print_shape_info</span>(shape: <span class="type">Shape</span>):
    <span class="string">"""어떤 Shape든 동일하게 처리 가능"""</span>
    <span class="function">print</span>(<span class="string">f"면적: {shape.<span class="function">area</span>():.2f}"</span>)
    <span class="function">print</span>(shape.<span class="function">draw</span>())

<span class="comment"># 4. Duck Typing (Python의 특징)</span>
<span class="keyword">class</span> <span class="type">Triangle</span>:  <span class="comment"># Shape를 상속하지 않음</span>
    <span class="keyword">def</span> <span class="function">area</span>(self) -> <span class="type">float</span>:
        <span class="keyword">return</span> <span class="number">10.0</span>

    <span class="keyword">def</span> <span class="function">draw</span>(self) -> <span class="type">str</span>:
        <span class="keyword">return</span> <span class="string">"삼각형을 그립니다"</span>

<span class="comment"># Duck Typing: "오리처럼 걷고 오리처럼 울면, 그것은 오리다"</span>
shapes = [Circle(<span class="number">5</span>), Rectangle(<span class="number">4</span>, <span class="number">6</span>), Triangle()]
<span class="keyword">for</span> shape <span class="keyword">in</span> shapes:
    <span class="function">print_shape_info</span>(shape)  <span class="comment"># Triangle도 동작함!</span></pre>
                </div>
            </div>
        </section>

        <!-- Practical Conversation -->
        <section class="term-section">
            <h2 class="section-title">
                <span class="icon">&#128483;</span>
                실무 대화 예시
            </h2>

            <div class="conversation-label">&#127891; 기술 면접: 다형성 종류 설명</div>
            <div class="conversation-container">
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-interviewer">&#128100;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-interviewer">면접관</div>
                        <div class="conversation-text">
                            다형성의 종류에 대해 설명해주세요. 서브타입 다형성과 파라메트릭 다형성의 차이점도 알려주시겠어요?
                        </div>
                    </div>
                </div>
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-candidate">&#128105;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-candidate">지원자</div>
                        <div class="conversation-text">
                            서브타입 다형성은 상속 관계를 통해 구현됩니다. 부모 클래스 타입으로 자식 클래스 객체를 다룰 수 있어서, <code>Animal animal = new Dog();</code>처럼 사용합니다. 런타임에 실제 객체 타입에 따라 메서드가 호출되죠.
                        </div>
                    </div>
                </div>
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-candidate">&#128105;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-candidate">지원자</div>
                        <div class="conversation-text">
                            파라메트릭 다형성은 타입을 매개변수로 받는 제네릭입니다. <code>List&lt;String&gt;</code>이나 <code>Map&lt;K, V&gt;</code>처럼 어떤 타입이든 담을 수 있는 컨테이너를 만들 수 있어요. 타입 안전성을 유지하면서도 재사용 가능한 코드를 작성할 수 있습니다.
                        </div>
                    </div>
                </div>
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-interviewer">&#128100;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-interviewer">면접관</div>
                        <div class="conversation-text">
                            그럼 오버로딩과 오버라이딩의 바인딩 시점 차이는요?
                        </div>
                    </div>
                </div>
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-candidate">&#128105;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-candidate">지원자</div>
                        <div class="conversation-text">
                            오버로딩은 컴파일 타임에 결정되는 정적 바인딩입니다. 메서드 호출 시 매개변수의 타입과 개수로 어떤 메서드를 호출할지 컴파일러가 결정해요. 반면 오버라이딩은 런타임에 결정되는 동적 바인딩입니다. 실제 객체의 타입에 따라 호출될 메서드가 결정되죠. 이게 가상 메서드 테이블(vtable)을 통해 구현됩니다.
                        </div>
                    </div>
                </div>
            </div>

            <hr class="conversation-divider">

            <div class="conversation-label">&#128269; 코드 리뷰: 다형성 활용</div>
            <div class="conversation-container">
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-reviewer">&#128104;&#8205;&#128187;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-reviewer">시니어 개발자 (리뷰어)</div>
                        <div class="conversation-text">
                            이 코드에서 <code>if (type == "email") sendEmail() else if (type == "sms") sendSMS()</code> 패턴이 반복되는데요. 새로운 알림 채널이 추가될 때마다 이 조건문을 모두 수정해야 해서 유지보수가 어려울 것 같아요.
                        </div>
                    </div>
                </div>
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-developer">&#128105;&#8205;&#128187;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-developer">주니어 개발자</div>
                        <div class="conversation-text">
                            아, <code>NotificationChannel</code> 인터페이스를 만들고 <code>send(message)</code> 메서드를 정의해서, <code>EmailChannel</code>, <code>SMSChannel</code> 클래스가 이를 구현하도록 하면 되겠네요. 그러면 호출하는 쪽은 그냥 <code>channel.send(message)</code>만 하면 되겠죠?
                        </div>
                    </div>
                </div>
                <div class="conversation-item">
                    <div class="conversation-avatar avatar-reviewer">&#128104;&#8205;&#128187;</div>
                    <div class="conversation-content">
                        <div class="conversation-role role-reviewer">시니어 개발자 (리뷰어)</div>
                        <div class="conversation-text">
                            정확해요! 그게 OCP(Open-Closed Principle)를 지키는 방법이에요. 새 채널이 추가되면 기존 코드 수정 없이 새 클래스만 추가하면 됩니다. 그리고 팩토리 패턴과 함께 쓰면 채널 생성 로직도 깔끔하게 분리할 수 있어요.
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Warning Section -->
        <section class="term-section">
            <h2 class="section-title">
                <span class="icon">&#9888;</span>
                주의사항
            </h2>
            <div class="warning-box">
                <div class="warning-title">&#128680; 다형성 관련 실무 주의사항</div>
                <ul class="warning-list">
                    <li><strong>LSP(리스코프 치환 원칙) 준수</strong>: 자식 클래스는 부모 클래스를 완벽히 대체할 수 있어야 합니다. <code>Rectangle</code>을 상속한 <code>Square</code>가 width와 height를 동시에 변경한다면 LSP 위반이에요. 상속보다 조합(Composition)을 고려하세요.</li>
                    <li><strong>타입 체크 대신 다형성 활용</strong>: <code>instanceof</code>나 <code>typeof</code>로 타입을 체크하고 분기하는 코드가 많다면, 다형성으로 리팩토링할 시점입니다. 조건문이 아닌 메서드 오버라이딩으로 해결하세요.</li>
                    <li><strong>인터페이스 분리 원칙(ISP)</strong>: 하나의 거대한 인터페이스보다 작고 구체적인 여러 인터페이스가 낫습니다. 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 설계하세요.</li>
                    <li><strong>추상화 수준 일관성</strong>: 같은 계층의 클래스들은 비슷한 추상화 수준을 유지해야 합니다. <code>sendEmail()</code>과 <code>updateDatabaseAndLogAndNotify()</code>가 같은 인터페이스에 있으면 안 됩니다.</li>
                    <li><strong>과도한 상속 계층 피하기</strong>: 3단계 이상의 상속 계층은 복잡성을 높입니다. 상속보다 인터페이스와 조합을 우선 고려하세요. "is-a" 관계가 명확할 때만 상속을 사용합니다.</li>
                </ul>
            </div>
        </section>

        <!-- Related Terms -->
        <section class="term-section">
            <h2 class="section-title">
                <span class="icon">&#128279;</span>
                관련 용어
            </h2>
            <div class="related-terms">
                <a href="https://glossary.kaitrust.ai/ko/term/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/" class="related-term-link">
                    <span>&#128230;</span> OOP
                </a>
                <a href="https://glossary.kaitrust.ai/ko/term/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/" class="related-term-link">
                    <span>&#128196;</span> Interface
                </a>
                <a href="https://glossary.kaitrust.ai/ko/term/Inheritance/" class="related-term-link">
                    <span>&#128257;</span> Inheritance
                </a>
                <a href="https://glossary.kaitrust.ai/ko/term/%EC%A0%9C%EB%84%A4%EB%A6%AD/" class="related-term-link">
                    <span>&#128290;</span> Generic
                </a>
                <a href="https://glossary.kaitrust.ai/ko/term/Abstract%20Class/" class="related-term-link">
                    <span>&#128203;</span> Abstract Class
                </a>
            </div>
        </section>

        <!-- Learn More -->
        <section class="term-section">
            <h2 class="section-title">
                <span class="icon">&#128218;</span>
                더 배우기
            </h2>
            <div class="learn-more-list">
                <a href="https://refactoring.guru/design-patterns/strategy" class="learn-more-item" target="_blank" rel="noopener noreferrer">
                    <span class="learn-more-icon">&#127891;</span>
                    <div class="learn-more-content">
                        <div class="learn-more-title">Refactoring Guru - Strategy Pattern</div>
                        <div class="learn-more-desc">다형성을 활용한 전략 패턴의 상세한 설명과 다양한 언어 예제</div>
                    </div>
                </a>
                <a href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html" class="learn-more-item" target="_blank" rel="noopener noreferrer">
                    <span class="learn-more-icon">&#128214;</span>
                    <div class="learn-more-content">
                        <div class="learn-more-title">Oracle Java Tutorial - Polymorphism</div>
                        <div class="learn-more-desc">Java 공식 튜토리얼에서 다형성의 개념과 활용법 설명</div>
                    </div>
                </a>
                <a href="https://docs.python.org/3/library/abc.html" class="learn-more-item" target="_blank" rel="noopener noreferrer">
                    <span class="learn-more-icon">&#128013;</span>
                    <div class="learn-more-content">
                        <div class="learn-more-title">Python abc 모듈 공식 문서</div>
                        <div class="learn-more-desc">Python에서 추상 클래스와 인터페이스를 정의하는 방법</div>
                    </div>
                </a>
                <a href="https://www.youtube.com/watch?v=kWGBOXmfMNk" class="learn-more-item" target="_blank" rel="noopener noreferrer">
                    <span class="learn-more-icon">&#127909;</span>
                    <div class="learn-more-content">
                        <div class="learn-more-title">Uncle Bob - SOLID Principles</div>
                        <div class="learn-more-desc">LSP와 다형성이 SOLID 원칙에서 어떻게 활용되는지 설명하는 강연</div>
                    </div>
                </a>
            </div>
        </section>

    </main>

    <!-- Footer -->
        <div id="kaitrust-footer"></div>

    <!-- Scripts -->
    <script>document.getElementById('currentYear').textContent = new Date().getFullYear();</script>
    <script>window.WIA_A11Y_CONFIG = { fabBottom: "38px", fabRight: "30px" };</script>
    <script src="https://wia.live/wia-a11y-toolkit/wia-a11y-toolkit.min.js"></script>
    <script src="/components/ask-ai/kaitrust-ai-modal.js"></script>
    <script src="/components/language-modal/wia-language-modal-211.js"></script>

    <!-- Copy Code Functionality -->
    <script>
        function copyCode(button) {
            const codeBlock = button.closest('.code-block');
            const codeContent = codeBlock.querySelector('pre').textContent;

            navigator.clipboard.writeText(codeContent).then(() => {
                const originalText = button.textContent;
                button.textContent = '복사됨!';
                button.classList.add('copied');

                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                button.textContent = '실패';
                setTimeout(() => {
                    button.textContent = '복사';
                }, 2000);
            });
        }
    </script>
<script src="/glossary/js/term-sections.js"></script>
    <script src="https://kaitrust.ai/components/site-kit/kaitrust-site-kit.js?v=20260130002"></script>
    <script src="/kaitrust-i18n.js?v=20260129"></script>
</body>
</html>
